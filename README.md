# Immortals SSL
Immortals code base for the Robocup Soccer Small-Size League.
The overall software architecture is to take information of the field from SSL-Vision over network, filter this information and pass them to the AI. The AI calculates a target for each robot. Finally, it transmits the processed data to the robots, in each frame.
![Overall](https://lightlordhippo.files.wordpress.com/2012/11/dataflow.png)

## Calculating World State 
Kalman filter is used for reducing noises, and predicting the future state. There are two types of input for the filter. For our robots, we use the data that is sent to the robots in previous frames, and for the ball and opponent robots, vision-calculated data is used.

### GP-GPU
Since the very beginning days of developing intelligent robots, achieving higher speed in data processing has been one of the most problematic challenges for designers. Intelligent robots have always been coupled with heavy and complex calculations, which are vital for them to be computed in the least time, achieving the least delay.
Regular processors known as CPUs leave designers with no option but to replace accurate and expensive algorithms with inaccurate and easy to compute ones to achieve the ultimate goal which is real-time processing.

![Field Evaluation](https://lightlordhippo.files.wordpress.com/2012/11/field_eval.png)

We boost data processing speed by executing some result-independent functions on the GPU. This method results a dramatic improvement in processing speed, promising emersion of some powerful but expensive, thus abandoned algorithms.

![Field Evaluation comparision](https://lightlordhippo.files.wordpress.com/2012/11/field_eval_comp.png)

Here is our paper: [A Novel Approach to Real-Time Processing: Implementing Complex Calculations on GPU](https://lightlordhippo.files.wordpress.com/2012/11/rios10_submission_24.pdf) 

## Decision Making 
The main method for this part is STP, developed by CMDragons and is tested since 2003, and the results show the success of this method. STP consists of Skills for executing the low-level actions that make up robot behavior and tactics for determining which skills to execute, and Plays for coordinating synchronized activity amongst team members. In our system, skills and tactics are script files, and plays are generated by either script files or the visual Strategy Maker software.

## Safe Navigation
### SB-RRT
The challenge of finding an optimized and reliable path dates back to emersion of mobile robots. Several approaches have been developed that have partially answered this need.

Satisfying results in previous implementations has led to an increased utilization of sampling-based motion planning algorithms in recent years, especially in high degrees of freedom (DOF), fast evolving environments. Another advantage of these algorithms is their probabilistic completeness that guarantees delivery of a path in sufficient time, if one exists.

![SB-RRT](https://lightlordhippo.files.wordpress.com/2014/06/sb-rrt.jpg)

On the other hand, sampling based motion planners leave no comment on safety of the planned path. This paper suggests biasing the Rapidly-exploring Random Trees (RRTs), with the outcome of a safety evaluation, which affects the probability of choosing a random point in the sampling phase of the RRT algorithm, to increase the chance of safer outcomes.

![SB-RRT Result](https://lightlordhippo.files.wordpress.com/2014/06/sb-rrt-result.png)

By parallelizing this algorithm and multifold execution of it on the Graphics Processing Unit (GPU) with various probabilities for moving to a safer state, a near-optimal solution is obtained.

![SB-RRT GP-GPU](https://lightlordhippo.files.wordpress.com/2014/06/sb-rrt-gpu.png)

Here is our paper: [A method for real-time safe navigation in noisy environments](http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=6669928&url=http%3A%2F%2Fieeexplore.ieee.org%2Fiel7%2F6661475%2F6669870%2F06669928.pdf%3Farnumber%3D6669928) 

### NOK-RRT
Near Optimal Kinodynamic RRT (NOK-RRT) is a joint kinodynamic motion planner, meaning it considers both positional restrictions (obstacles and boundaries), and dynamics in the planning at the same time. Itâ€™s based on the well-known RRT algorithm, and so is a sampling-based probabilistic planner.
In contrast to basic RRT, NOK-RRT plans in a 4D state space. Benefits of being a joint planner is decreasing the probability of failure in highly dynamic and obstacle rich environments.
This method also plans many times, and find the shortest path, in terms of path traversal time, not the positional length. Because of the dynamic limits each mobile robot has, the acceleration, deceleration, and cruising speed should be considered to compute the total traversal time. So the least traversal time, which seems to be the optimal solution, does not always correspond to the shortest path.
The multiple iterations are done on the GPU, using our GP-GPU RRT framework, and because of very high number of planning iterations, the output path is near optimal in terms of both failure rate and traversal time.
![NOK-RRT Result](https://lightlordhippo.files.wordpress.com/2012/11/170962_190521667631553_6635028_o.jpg)
### Dynamic Safety Search
Dynamic Safety Search (DSS) is a multi-agent sampling-based dynamic path planning method. In contrast to positional planners (e.g. ERRT) it considers each agent kinematic parameters and current velocities in planning. DSS is proposed by J. R. Bruce, and is an improvement over the well-known Dynamic Window method. The main improvements are:
* Replacing grid-base sampling with random sampling
* Being multi-agent, meaning it can generate a safe path for any number of agents
The set of possible accelerations used in DSS calculation is also recalculated, using our actual robot model which is based on BLDC motor equation. The author proposed that acceleration space plot of the set is likely to be a partial ellipse, but based on our computations, it actually is a diamond.
In our AI software, the output of the ERRT planner is fed into the motion planner, and an acceleration vector is generated for the robot. Then this vector is passed to the DSS as the input, and a safe acceleration vector f is generated.
On the implementation side, the DSS algorithm generates the result for all robots simultaneously, so it cannot be parallelized. But because of its anytime basis, it can be terminated whenever required, and it will give the best found result. In our experiments, it almost always gives good enough results in the given 0.2 mS time.

## Strategy Maker 
Because it is harder to code strategies even with scripting, so a tool had to be built to make it easy for everyone to propose strategies so we develop a visual editor tool for making the strategies and send the final to AI as a message containing strategies. The messaging is implemented using Google protobuf. This message can be delivered to the AI using either UDP or a file. Then the AI software use these strategies in every free kick to assign roles to the robots. So with this tool we can choose when the robot can start the play and the other robots role. In each game the AI have to select one of the strategies depends on their probability which is assigned manually. In this year we let the AI change the probabilities automatically based on the scoring and result of running that strategies to do the best. The final roles in this software can choose between the wait for pass on the position, wait for pass in best position, attract the defenders, run away, go to position, shoot directly to goal and etc. The following image is a screenshot of the strategy maker software that shows a strategy for the corner kick. In this strategy if all the robots reach their targets, the purple robot pass directly to the red robot to pass-shoot to the goal. 

![STM](https://lightlordhippo.files.wordpress.com/2012/11/strategy.jpg)

## Simulator
To avoid possible damages of running the actual robots to test new algorithms, such as new path planners, a soccer simulator is developed. The simulator uses internal physic-based robot model described here. The Newton Dynamics physics engine is used because of its deterministic calculations.

![Simulator](https://lightlordhippo.files.wordpress.com/2012/11/immsim.jpg)

The simulator outputs the data with the same protocol as the vision software, so the AI is unaware whether the incoming data is from the actual vision, or from the simulator.
The input command data also uses the same protocol as our wireless interface board.
For both vision data, and robot command data, the noise is simulated using white noise pattern, and the noise amount can be changed to test algorithms in different environmental situations.
This way the same filtering and fusion can be used in both real robot and simulation cases.
